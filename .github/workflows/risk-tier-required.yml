name: "ðŸ° PhishFort Risk Tier Profiler (Required)"

on:
  pull_request:
    types: [opened, synchronize, reopened]

permissions:
  contents: read
  pull-requests: write
  id-token: write

jobs:
  classify:
    runs-on: ubuntu-latest
    timeout-minutes: 10

    steps:
      - name: Checkout caller repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Checkout central policy repository
        uses: actions/checkout@v4
        with:
          repository: phishfort/risk-tier-policy-gate
          path: .risk-tier-policy-gate

      - name: Resolve policy file paths
        id: resolve
        shell: bash
        run: |
          set -euo pipefail

          CENTRAL_RULES=".risk-tier-policy-gate/config/risk-rules.json"
          CENTRAL_CONDITIONS=".risk-tier-policy-gate/risk-tier-conditions.md"

          RULES_PATH="$CENTRAL_RULES"
          if [[ -f "risk-rules.json" ]]; then
            RULES_PATH="risk-rules.json"
          fi

          CONDITIONS_PATH="$CENTRAL_CONDITIONS"
          if [[ -f "risk-tier-conditions.md" ]]; then
            CONDITIONS_PATH="risk-tier-conditions.md"
          fi

          echo "rules_path=$RULES_PATH" >> "$GITHUB_OUTPUT"
          echo "conditions_path=$CONDITIONS_PATH" >> "$GITHUB_OUTPUT"

      - name: Collect changed files
        env:
          BASE_SHA: ${{ github.event.pull_request.base.sha }}
          HEAD_SHA: ${{ github.sha }}
        run: |
          set -euo pipefail
          git diff --name-only "$BASE_SHA" "$HEAD_SHA" > changed-files.txt
          if [[ ! -s changed-files.txt ]]; then
            echo "No changed files detected" >&2
            exit 1
          fi
          echo "Changed files:" && cat changed-files.txt

      - name: PR size check
        id: size
        env:
          BASE_SHA: ${{ github.event.pull_request.base.sha }}
          HEAD_SHA: ${{ github.sha }}
        run: |
          set -euo pipefail
          FILE_COUNT=$(wc -l < changed-files.txt | tr -d ' ')
          LINE_COUNT=$(git diff --shortstat "$BASE_SHA" "$HEAD_SHA" | grep -oP '\d+ insertion' | grep -oP '\d+' || echo 0)
          echo "file_count=$FILE_COUNT" >> "$GITHUB_OUTPUT"
          echo "line_count=$LINE_COUNT" >> "$GITHUB_OUTPUT"
          LARGE_PR=false
          if [[ "$FILE_COUNT" -ge 50 ]] || [[ "$LINE_COUNT" -ge 1000 ]]; then
            LARGE_PR=true
          fi
          echo "large_pr=$LARGE_PR" >> "$GITHUB_OUTPUT"
          echo "Files: $FILE_COUNT, Lines added: $LINE_COUNT, Large PR: $LARGE_PR"

      - name: Deterministic risk pre-check
        id: rules
        env:
          RULES_PATH: ${{ steps.resolve.outputs.rules_path }}
        run: |
          set -euo pipefail
          node .risk-tier-policy-gate/scripts/risk-rules.mjs changed-files.txt "$RULES_PATH"

      - name: Force high-risk label for large PRs
        if: steps.size.outputs.large_pr == 'true' && steps.rules.outputs.forced_high != 'true'
        uses: actions/github-script@v7
        with:
          script: |
            const owner = context.repo.owner;
            const repo = context.repo.repo;
            const issue_number = context.payload.pull_request.number;
            const botLabelPrefix = 'risktier:';
            const targetLabel = 'risktier:high';
            const fileCount = '${{ steps.size.outputs.file_count }}';
            const lineCount = '${{ steps.size.outputs.line_count }}';

            const { data: labels } = await github.rest.issues.listLabelsOnIssue({ owner, repo, issue_number });
            for (const l of labels) {
              if (l.name.startsWith(botLabelPrefix) && l.name !== targetLabel) {
                await github.rest.issues.removeLabel({ owner, repo, issue_number, name: l.name }).catch(() => {});
              }
            }

            await github.rest.issues.addLabels({ owner, repo, issue_number, labels: [targetLabel] });

            const marker = '<!-- risktier-bot-comment -->';
            const body = [
              marker,
              'ðŸ° **PhishFort Risk Tier Profiler** â€” Risk tier: **HIGH**',
              '',
              `This PR is large (${fileCount} files, ${lineCount}+ lines added) and has been automatically flagged for human review.`,
              '',
              '**Resources:**',
              '- [Risk tier policy conditions](https://github.com/phishfort/risk-tier-policy-gate/blob/main/risk-tier-conditions.md)',
              '- [Deterministic rule definitions](https://github.com/phishfort/risk-tier-policy-gate/blob/main/config/risk-rules.json)'
            ].join('\n');

            const { data: comments } = await github.rest.issues.listComments({ owner, repo, issue_number });
            const existing = comments.find(c => c.body.includes(marker) && c.user.login === 'github-actions[bot]');
            if (existing) {
              await github.rest.issues.updateComment({ owner, repo, comment_id: existing.id, body });
            } else {
              await github.rest.issues.createComment({ owner, repo, issue_number, body });
            }

      - name: Force high-risk label from deterministic rules
        if: steps.rules.outputs.forced_high == 'true' && steps.size.outputs.large_pr != 'true'
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            const owner = context.repo.owner;
            const repo = context.repo.repo;
            const issue_number = context.payload.pull_request.number;
            const botLabelPrefix = 'risktier:';
            const targetLabel = 'risktier:high';

            const { data: labels } = await github.rest.issues.listLabelsOnIssue({ owner, repo, issue_number });
            for (const l of labels) {
              if (l.name.startsWith(botLabelPrefix) && l.name !== targetLabel) {
                await github.rest.issues.removeLabel({ owner, repo, issue_number, name: l.name }).catch(() => {});
              }
            }

            await github.rest.issues.addLabels({ owner, repo, issue_number, labels: [targetLabel] });

            const result = JSON.parse(fs.readFileSync('risk-result.json', 'utf8'));
            const byCategory = {};
            for (const hit of result.high_hits) {
              (byCategory[hit.category] ??= []).push(hit.file);
            }
            const triggerLines = Object.entries(byCategory).map(([cat, files]) => {
              const label = cat.replace(/_/g, ' ');
              const fileList = files.map(f => `\`${f}\``).join(', ');
              return `- **${label}**: ${fileList}`;
            });

            const marker = '<!-- risktier-bot-comment -->';
            const body = [
              marker,
              'ðŸ° **PhishFort Risk Tier Profiler** â€” Risk tier: **HIGH**',
              '',
              'Flagged by deterministic policy rules. Human review is required before merging.',
              '',
              '**Triggered rules:**',
              ...triggerLines,
              '',
              '**Resources:**',
              '- [Risk tier policy conditions](https://github.com/phishfort/risk-tier-policy-gate/blob/main/risk-tier-conditions.md)',
              '- [Deterministic rule definitions](https://github.com/phishfort/risk-tier-policy-gate/blob/main/config/risk-rules.json)'
            ].join('\n');

            const { data: comments } = await github.rest.issues.listComments({ owner, repo, issue_number });
            const existing = comments.find(c => c.body.includes(marker) && c.user.login === 'github-actions[bot]');
            if (existing) {
              await github.rest.issues.updateComment({ owner, repo, comment_id: existing.id, body });
            } else {
              await github.rest.issues.createComment({ owner, repo, issue_number, body });
            }

      - name: LLM classify + label (non-forced cases)
        if: steps.rules.outputs.forced_high != 'true' && steps.size.outputs.large_pr != 'true' && env.CLAUDE_CODE_OAUTH_TOKEN != ''
        uses: anthropics/claude-code-action@v1
        env:
          CLAUDE_CODE_OAUTH_TOKEN: ${{ secrets.CLAUDE_CODE_OAUTH_TOKEN }}
        with:
          claude_code_oauth_token: ${{ secrets.CLAUDE_CODE_OAUTH_TOKEN }}
          claude_args: "--model sonnet --max-turns 15 --allowedTools Bash,View,GlobTool,GrepTool,GitHub"
          prompt: |
            Classify this PR and apply exactly one label: `risktier:high` or `risktier:low`.

            Deterministic pre-check result:
            - tier: `${{ steps.rules.outputs.deterministic_tier }}`
            - forced_high: `${{ steps.rules.outputs.forced_high }}`
            - all_low_safe: `${{ steps.rules.outputs.all_low_safe }}`

            Read `risk-result.json` for changed files and pre-check details.
            Read `${{ steps.resolve.outputs.conditions_path }}` for risk-tier policy conditions.

            Rules:
            1) If ANY high-risk category applies, choose `risktier:high`.
            2) Otherwise choose `risktier:low`.
            3) Remove incorrect existing `risktier:` labels before applying.
            4) Before posting a comment, search for an existing comment containing `<!-- risktier-bot-comment -->` by `github-actions[bot]`. If found, update it. Otherwise create a new comment.
            5) The comment must start with `<!-- risktier-bot-comment -->` (hidden marker), then "ðŸ° **PhishFort Risk Tier Profiler** â€” Risk tier: **HIGH/LOW**" and include:
               - 2-5 matched categories/reasons
               - Whether human review is required
               - A resources section with these links:
                 - [Risk tier policy conditions](https://github.com/phishfort/risk-tier-policy-gate/blob/main/risk-tier-conditions.md)
                 - [Deterministic rule definitions](https://github.com/phishfort/risk-tier-policy-gate/blob/main/config/risk-rules.json)

      - name: Fallback if LLM unavailable
        if: steps.rules.outputs.forced_high != 'true' && steps.size.outputs.large_pr != 'true' && env.CLAUDE_CODE_OAUTH_TOKEN == ''
        uses: actions/github-script@v7
        env:
          CLAUDE_CODE_OAUTH_TOKEN: ${{ secrets.CLAUDE_CODE_OAUTH_TOKEN }}
        with:
          script: |
            const owner = context.repo.owner;
            const repo = context.repo.repo;
            const issue_number = context.payload.pull_request.number;
            const botLabelPrefix = 'risktier:';
            const targetLabel = 'risktier:high';

            const { data: labels } = await github.rest.issues.listLabelsOnIssue({ owner, repo, issue_number });
            for (const l of labels) {
              if (l.name.startsWith(botLabelPrefix) && l.name !== targetLabel) {
                await github.rest.issues.removeLabel({ owner, repo, issue_number, name: l.name }).catch(() => {});
              }
            }

            await github.rest.issues.addLabels({ owner, repo, issue_number, labels: [targetLabel] });

            const marker = '<!-- risktier-bot-comment -->';
            const body = [
              marker,
              'ðŸ° **PhishFort Risk Tier Profiler** â€” Risk tier: **HIGH** (fallback)',
              '',
              'LLM classification was unavailable. Defaulting to high risk as a precaution. Human review is required before merging.',
              '',
              '**Resources:**',
              '- [Risk tier policy conditions](https://github.com/phishfort/risk-tier-policy-gate/blob/main/risk-tier-conditions.md)',
              '- [Deterministic rule definitions](https://github.com/phishfort/risk-tier-policy-gate/blob/main/config/risk-rules.json)'
            ].join('\n');

            const { data: comments } = await github.rest.issues.listComments({ owner, repo, issue_number });
            const existing = comments.find(c => c.body.includes(marker) && c.user.login === 'github-actions[bot]');
            if (existing) {
              await github.rest.issues.updateComment({ owner, repo, comment_id: existing.id, body });
            } else {
              await github.rest.issues.createComment({ owner, repo, issue_number, body });
            }

      - name: Auto-approve low-risk / dismiss bot approval for high-risk
        if: always()
        uses: actions/github-script@v7
        with:
          script: |
            const owner = context.repo.owner;
            const repo = context.repo.repo;
            const pr_number = context.payload.pull_request.number;

            const { data: labels } = await github.rest.issues.listLabelsOnIssue({
              owner, repo, issue_number: pr_number
            });
            const tierLabel = labels.find(l => l.name.startsWith('risktier:'));
            if (!tierLabel) {
              core.warning('No risktier label found â€” skipping auto-approve');
              return;
            }

            if (tierLabel.name === 'risktier:low') {
              await github.rest.pulls.createReview({
                owner, repo, pull_number: pr_number,
                event: 'APPROVE',
                body: 'ðŸ° **PhishFort Risk Tier Profiler** â€” Auto-approved (low risk).'
              });
              core.info('Auto-approved low-risk PR');
            } else if (tierLabel.name === 'risktier:high') {
              const { data: reviews } = await github.rest.pulls.listReviews({
                owner, repo, pull_number: pr_number
              });
              for (const review of reviews) {
                if (review.user.login === 'github-actions[bot]' && review.state === 'APPROVED') {
                  await github.rest.pulls.dismissReview({
                    owner, repo, pull_number: pr_number,
                    review_id: review.id,
                    message: 'ðŸ° **PhishFort Risk Tier Profiler** â€” Dismissing auto-approval. PR re-classified as HIGH risk. Human review required.'
                  });
                }
              }

              // Request review from collaborators with write access (excluding PR author)
              const prAuthor = context.payload.pull_request.user.login;
              try {
                const { data: collaborators } = await github.rest.repos.listCollaborators({
                  owner, repo, permission: 'push'
                });
                const reviewers = collaborators
                  .filter(u => u.login !== prAuthor && u.type === 'User')
                  .map(u => u.login);
                if (reviewers.length > 0) {
                  await github.rest.pulls.requestReviewers({
                    owner, repo, pull_number: pr_number,
                    reviewers
                  });
                  core.info(`Requested review from: ${reviewers.join(', ')}`);
                } else {
                  core.warning('No eligible reviewers found');
                }
              } catch (err) {
                core.warning(`Failed to request reviewers (${err.status}): ${err.message}`);
              }

              core.info('High-risk PR â€” human review required');
            }
